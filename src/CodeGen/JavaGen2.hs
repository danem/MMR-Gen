{-# LANGUAGE RecordWildCards #-}
{-# LANGUAGE NoOverloadedStrings #-}
module CodeGen.JavaGen2 (
    generateJavaCode
) where

import AST.Register
import CodeGen.Types
import CodeGen.CodeGenUtils

import Control.Monad
import Control.Monad.State
import Control.Applicative
import Data.Maybe 
import Data.Word

import qualified Data.Foldable as F
import qualified Data.Traversable as F
import qualified Data.List as L

import Text.Printf
import System.FilePath

import AST.Parser
import Data.Time

import qualified Data.Map as M
import Debug.Trace

javaRegisterFieldType :: RegisterField -> String
javaRegisterFieldType (RegisterFieldUnion{..}) = "int"
javaRegisterFieldType (RegisterField{..}) = if fieldBitSize == 1 then "boolean" else "int"

jFieldTypeDefault :: RegisterField -> String
jFieldTypeDefault (RegisterFieldUnion{..}) = ""
jFieldTypeDefault (RegisterField{..}) = do
    if fieldBitSize == 1
        then if fieldDefault == 0
            then "false"
            else "true"
        else show fieldDefault

javaWarningComment :: CodeGenerator String
javaWarningComment = do 
    ver <- gets genVersion
    t  <- gets genDate
    return $ concat [
        printf "/** Generated by RTL-Gen compiler version: %s on %s.\n" ver (show t),
        " *\n",
        " * DO NOT EDIT UNLESS YOU KNOW WHAT YOU ARE DOING\n",
        " * @generated\n",
        " */\n\n"
        ]


indent :: Int -> String -> String
indent n txt = do
    let t = replicate (n*4) ' '
    let l = lines txt
    F.foldl' (\s v -> s ++ (t ++ v ++ "\n")) "" l

javaStmt :: String -> String
javaStmt expr = expr ++ ";\n"

javaStmts :: (a -> String) -> [a] -> String
javaStmts fn l = F.foldl (\s a -> s ++ (javaStmt $ fn a)) "" l

javaLines fn l = concat $ fmap fn l

javaInteger :: String
javaInteger = "Integer"

javaPrivate :: String
javaPrivate = "private"

javaPublic :: String
javaPublic = "public"

javaImport :: String -> String
javaImport pkg = "import " ++ javaStmt pkg

javaReturn :: String -> String
javaReturn v = "return " ++ javaStmt v 

javaMethodCall :: String -> String -> [String] -> String
javaMethodCall obj m args = obj ++ "." ++ m ++ "(" ++ L.intercalate ", " args ++ ")"

javaMethodDecl :: String -> String -> String -> [String] -> String -> String
javaMethodDecl access ret name args body = access ++ " " 
                                        ++ ret ++ " " 
                                        ++ name ++ " (" ++ L.intercalate ", " args ++ "){\n"
                                        ++ indent 1 body ++ "}\n\n"

javaClassDecl :: String -> String -> Bool -> Bool -> Maybe String -> String
javaClassDecl name body access static extends = do
    let access' = (if access then "public" else "private") :: String
    let static' = (if static then " static" else "") :: String
    let extends' = fromMaybe "" (fmap (\s -> " extends " ++ s) extends)
    printf "%s%s class %s%s {\n%s\n}\n\n" access' static' name extends' (indent 1 body)


javaEnumLines :: [String] -> String
javaEnumLines idents = do
    let len = length idents
    let makeEntry s (i,n) = do
          let sep = if i /= len then ",\n" else ";\n"
          s ++ " " ++ n ++ sep
    F.foldl' makeEntry "" (zip [1..] idents)


javaEnum :: String -> [String] -> String
javaEnum name idents = do 
    let o = "public enum " ++ name ++ " {\n"
    let b = javaEnumLines idents
    o ++ b ++ "}\n"

javaVarDecl :: String -> String -> String -> String
javaVarDecl typ name val = javaStmt $ printf "%s %s = %s" typ name val

javaStaticBlock :: String -> String
javaStaticBlock body = "static {\n" ++ body ++ "}\n\n"

javaConst :: String -> String -> String
javaConst name val = "public static final int " ++ name ++ " = " ++ val ++ ";\n"

javaAssignment :: String -> String -> String -> String
javaAssignment obj field val = printf "%s.%s = %s;\n" obj field val

javaCastIntToBoolean :: String -> String -> String
javaCastIntToBoolean var temp = javaVarDecl "boolean" temp (printf "%s == 1" var)

javaCastBooleanToInt :: String -> String -> String
javaCastBooleanToInt var temp = javaVarDecl "int" temp (printf "%s ? 1 : 0" var)

javaFieldDecl :: String -> String -> Maybe String -> Bool -> Bool -> String
javaFieldDecl typ name val public static = do
    let public' = if public then "public" else "private" :: String
    let static' = if static then "static " else "" :: String
    let val' = fromMaybe "" (fmap (" = " ++) val)
    printf "%s %s%s %s%s;\n" public' static' typ name val' :: String

toJavaFile :: String -> String
toJavaFile s = s ++ ".java"

toJavaPackage :: String -> String
toJavaPackage = id -- TODO

javaPackage :: String -> String
javaPackage name = (javaStmt $ "package " ++ name) ++ "\n"

javaFile :: String -> String -> CodeGenerator GeneratedFile
javaFile fileName source = do
    ns   <- gets genNamespace
    warn <- javaWarningComment
    let jpkg = javaPackage ns
    let src  = jpkg ++ warn ++ source
    return $ GeneratedFile src $ toJavaFile (ns </> fileName)


----------------------
-- RTLRegisterType Gen
----------------------
javaRTLSetParam :: String
javaRTLSetParam = "data"

javaRTLExtractParam :: String
javaRTLExtractParam = "x"

javaRTLTempParam :: String
javaRTLTempParam = "temp"

jRegTypesKey :: String
jRegTypesKey = "jRegTypes"

jRegBuilderKey :: String
jRegBuilderKey = "jRegBuilder"

javaExtractBytes :: Word32 -> Word32 -> Word32 -> String
javaExtractBytes word hi lo = javaMethodCall "this" "extractBytes" [show word, show hi, show lo]

javaShiftAndMaskBytes :: String -> Word32 -> Word32 -> String
javaShiftAndMaskBytes val hi lo = javaMethodCall "this" "maskAndShift" [val, show hi, show lo]

javaRegisterTypeFields :: [RegisterField] -> String
javaRegisterTypeFields fields = do
    let fd (RegisterFieldUnion{..}) = ""
        fd r@(RegisterField{..}) = do
          let typ  = javaRegisterFieldType r
          let val  = jFieldTypeDefault r
          let name = fieldName
          javaFieldDecl typ name (Just val) False False
    javaLines fd fields

javaReverseGetter :: RegisterField -> String
javaReverseGetter (RegisterFieldUnion{..}) = javaReturn $ L.intercalate " | " $ fmap javaReverseGetter fieldUnionMembers
javaReverseGetter (RegisterField{..}) = do
    let arg = "this." ++ fieldName
    javaMethodCall "Utils" "maskAndShift" [arg, show fieldBitHigh, show fieldBitLow]
    

javaRegisterFieldGet :: RegisterField -> String
javaRegisterFieldGet r@(RegisterFieldUnion{..}) = javaReverseGetter r
javaRegisterFieldGet (RegisterField{..}) = do
    --let wordO = div (fieldWordOffset*4) 4
    {-
    let wordO = fieldWordOffset
    let ext = javaVarDecl "int" javaRTLExtractParam $ javaExtractBytes wordO fieldBitHigh fieldBitLow
    ext ++ if fieldBitSize /= 1
      then javaReturn "x"
      else javaCastIntToBoolean "x" "temp" ++ javaReturn "temp"
    -}
    printf "return this.%s;\n" fieldName

javaRegisterFieldGetter :: RegisterField -> String
javaRegisterFieldGetter r = do
    let name = "get_" ++ registerFieldName r
    let typ  = javaRegisterFieldType r
    javaMethodDecl javaPublic typ name [] (javaRegisterFieldGet r)

javaReverseSetter :: RegisterField -> String
javaReverseSetter (RegisterFieldUnion{..}) = javaLines javaReverseSetter fieldUnionMembers
javaReverseSetter (RegisterField{..}) = do
    let extract = javaMethodCall "Utils" "extractBytes" [javaRTLSetParam, show fieldBitHigh, show fieldBitLow]
    let val     = if fieldBitSize == 1 then extract ++ " == 1" else extract
    javaAssignment "this" fieldName val

javaRegisterFieldSet :: RegisterField -> String
javaRegisterFieldSet r@(RegisterFieldUnion{..}) = javaReverseSetter r ++ javaReturn "this"
javaRegisterFieldSet (RegisterField{..}) = do
    let (castStmt,var) = ("", javaRTLSetParam)
    let set = printf "this.%s = %s;\n" fieldName var
    castStmt ++ set ++ javaReturn "this"

javaRegisterFieldSetter :: String -> RegisterField -> String
javaRegisterFieldSetter className r = do
    let name = "set_" ++ registerFieldName r
    let typ  = javaRegisterFieldType r
    let body = javaRegisterFieldSet r
    javaMethodDecl javaPublic className name [typ ++ " " ++ javaRTLSetParam] body

javaRegisterFieldSet' :: RegisterField -> String
javaRegisterFieldSet' (RegisterFieldUnion{..}) = ""
javaRegisterFieldSet' (RegisterField{..}) = do
    let var = "this." ++ fieldName :: String
    let cast = if fieldBitSize == 1 then " ? 1 : 0" else ""
    javaStmt $ javaShiftAndMaskBytes (var ++ cast) fieldBitHigh fieldBitLow
    

javaRTLRegisterTypeGetValues :: RegisterType ->  String
javaRTLRegisterTypeGetValues r@(RegisterType{..}) = do
    let fnName = "getValues" :: String
    let fnBody'' = "this.reset();\n"
    let fnBody' = javaLines javaRegisterFieldSet' registerTypeFields
    let fnBody  = fnBody'' ++ fnBody' ++ "return this.values;\n"
    javaMethodDecl javaPublic "int[]" fnName [] fnBody


javaRTLRegisterTypeGetSet :: String -> RegisterField -> String
javaRTLRegisterTypeGetSet className r= do
    javaRegisterFieldGetter r ++ javaRegisterFieldSetter className r

javaRTLRegisterTypeConstructors :: String -> RegisterType -> String
javaRTLRegisterTypeConstructors name (RegisterType{..}) = do
    let types  = fmap javaRegisterFieldType registerTypeFields
    let fnames = fmap registerFieldName $ registerTypeFields
    let cArgs  = zipWith (\a b-> a ++ " " ++ b) types fnames
    --let intC   = ceiling $ (fromIntegral registerTypeWordCount) / 4
    let intC   = registerTypeByteSize
    let bodyS  = "super(" ++ show intC ++ ");\n"
    let body   = "this();\n" ++ (concat $ fmap (\n -> javaStmt $ javaMethodCall "this" ("set_"++n) [n]) fnames)
    let c1     = javaMethodDecl javaPublic name "" cArgs body
    let c2     = javaMethodDecl javaPublic name "" [] bodyS
    c2 ++ c1
    

javaRTLRegisterTypeClassBody :: String -> RegisterType -> String
javaRTLRegisterTypeClassBody name r@(RegisterType{..}) = do
    let getsets = F.foldl' (\s f -> s ++ (javaRTLRegisterTypeGetSet name f)) "" registerTypeFields
    let getVals = javaRTLRegisterTypeGetValues r
    getsets ++ getVals

javaRegisterTypeNameToClass :: String -> String
javaRegisterTypeNameToClass n = toCamelCase n ++ "RegisterType"

javaRTLRegisterTypeDecl :: RegisterType -> String
javaRTLRegisterTypeDecl r@(RegisterType {..}) = do
    let name = javaRegisterTypeNameToClass registerTypeName
    let body = (javaRegisterTypeFields registerTypeFields) ++ "\n"
            ++ (javaRTLRegisterTypeConstructors name r) ++ "\n"
            ++ (javaRTLRegisterTypeClassBody name r)
    javaClassDecl name body True True (Just "RTLRegisterType")

javaRTLRegisterTypeClass :: RTL -> CodeGenerator GeneratedFile
javaRTLRegisterTypeClass r@(RTL{..}) = do
    let name = "RegisterBuilders" :: String
    let imports = concat [javaImport "com.samsung.ttt.rtlgen.RTLRegisterType", javaImport "com.samsung.ttt.rtlgen.Utils", "\n"]
    let body = F.foldl' (\s c -> s ++ javaRTLRegisterTypeDecl c) "" rtlRegisterTypes
    let klass = javaClassDecl name body True False Nothing
    javaFile name (imports ++ klass)

-------------------------
-- RTL Register Accessors
-------------------------
-- This generates: 
--     Register -> Address mappings
--     RegisterType -> Register mappings (and as a result...) 
--     RegisterType -> Address mappings

jRegEnumKey :: String
jRegEnumKey = "jRegEnum"

jAddrMapKey :: String
jAddrMapKey = "jAddrMapKey"

jTypesEnumKey :: String
jTypesEnumKey = "jTypesEnum"

jTypeMapKey :: String
jTypeMapKey = "jTypeMapKey"

javaRegTypeEnum :: [RegisterType] -> CodeGenerator String
javaRegTypeEnum types = do
    let names = fmap registerTypeName types
    addGenName jTypesEnumKey ("RegisterType" :: String)
    return $ javaEnum "RegisterType" names

groupRegistersByType :: [Register] -> [(String,[Register])]
groupRegistersByType regs = do
    let add m r@(Register{..}) = M.insertWith (flip (++)) (registerTypeName registerType) [r] m
    M.toList $ F.foldl' add M.empty regs
    

javaTypeMap :: [Register] -> CodeGenerator String
javaTypeMap regs = do
    tEnum <- getGenName jTypesEnumKey
    rEnum <- getGenName jRegEnumKey
    let mapName = "_register_type_map" :: String
    addGenName jTypeMapKey mapName
    let mapDecl   = printf "private static Map<%s,%s[]> %s = new HashMap<>();\n" tEnum rEnum mapName
    let groups    = groupRegistersByType regs
    let toJName x = rEnum ++ "." ++ registerName x
    let mapping   = fmap (\(s,x) -> (s,fmap toJName x)) groups
    let arrdecl f = (printf "new %s[]{%s}" rEnum (L.intercalate ", " f)) :: String
    let mapPut (a,b) = (printf "%s.put(%s.%s, %s);\n" mapName tEnum a (arrdecl b)) :: String
    let mapDef = javaStaticBlock $ javaLines mapPut mapping
    return $ mapDecl ++ mapDef

javaRegEnum :: [Register] -> CodeGenerator String
javaRegEnum regs = do
    let names = fmap registerName regs
    addGenName jRegEnumKey ("Register" :: String)
    return $ javaEnum "Register" names

javaAddressMap :: [Register] -> CodeGenerator String
javaAddressMap regs = do
    let addrMapName = "_register_address_map" :: String
    addGenName jAddrMapKey addrMapName
    regType <- getGenName jRegEnumKey
    let mapDecl = printf "private static Map<%s,Integer> %s = new HashMap<>();\n" regType addrMapName
    let mapPut (Register{..}) = printf "%s.put(%s.%s,0x%08x);\n" addrMapName regType registerName (fromJust registerAddress)

    let mapDef = javaStaticBlock $ javaLines mapPut regs
    return $ mapDecl ++ "\n" ++ mapDef

javaAddressGetter :: CodeGenerator String
javaAddressGetter = do
    mapName  <- getGenName jAddrMapKey
    enumType <- getGenName jRegEnumKey
    let argName = "reg" :: String
    let body = printf "return %s.get(%s);\n" mapName argName
    return $ javaMethodDecl javaPublic "static int" "getRegisterAddress" [enumType ++ " " ++ argName] body

javaTypeGetter :: CodeGenerator String
javaTypeGetter = do
    mapName  <- getGenName jTypeMapKey
    enumType <- getGenName jTypesEnumKey
    rEnum    <- getGenName jRegEnumKey
    let argName = "type" :: String
    let body = printf "return %s.get(%s);\n" mapName argName
    let ret  = printf "static %s[]" rEnum
    return $ javaMethodDecl javaPublic ret "getRegistersOfType" [enumType ++ " " ++ argName] body

javaTypeAddrGetter :: CodeGenerator String
javaTypeAddrGetter = do
    mapName  <- getGenName jTypeMapKey
    enumType <- getGenName jTypesEnumKey
    rEnum    <- getGenName jRegEnumKey
    let arrDecl = printf "%s[] regs = getRegistersOfType(type);\n" rEnum
    let retDecl = "int[] addrs = new int[regs.length];\n" :: String
    let forLoop = "for (int i = 0; i < regs.length; i++){\n  addrs[i] = getRegisterAddress(regs[i]);\n}\n"
    let src     = arrDecl ++ retDecl ++ forLoop ++ "return addrs;\n"
    return $ javaMethodDecl javaPublic "static int[]" "getTypeAddresses" [enumType ++ " " ++ "type"] src

javaRegisterAccessors :: RTL -> CodeGenerator GeneratedFile
javaRegisterAccessors (RTL{..}) = do
    let regs = rtlMappings
    let fileName = "RegisterAccessor"
    let imports = concat [javaImport "java.util.Map"
                        , javaImport "java.util.HashMap", "\n"]
    enum     <- javaRegEnum regs
    tEnum    <- javaRegTypeEnum rtlRegisterTypes
    addrs    <- javaAddressMap regs
    tMap     <- javaTypeMap regs
    getter   <- javaAddressGetter 
    tgetter  <- javaTypeGetter
    tagetter <- javaTypeAddrGetter
    let body = L.intercalate "\n" [enum, tEnum, tMap, addrs, getter, tgetter, tagetter]
    let klass = javaClassDecl fileName body True False Nothing
    let src = imports ++ klass
    javaFile fileName src


----------------------
-- Java Register Enum
----------------------

javaRegisterEnum :: RTL -> CodeGenerator GeneratedFile
javaRegisterEnum (RTL{..}) = do
    let filename = "Register"
    addGenName "RegisterEnum" filename
    typeEnum <- getGenName jTypesEnumKey
    --let typeEnum = "RegisterType"
    ns <- gets genNamespace
    let imports = concat [javaImport "java.util.Map"
                        , javaImport "java.util.HashMap"
                        , javaImport "java.util.EnumSet"
                        , javaImport "java.util.List"
                        , javaImport "java.util.ArrayList"
                        , javaImport (ns ++ "." ++ typeEnum),  "\n"]
    let getRegType (Register{..})  = typeEnum ++ "." ++ (registerTypeName registerType)
    let mkRegDef r@(Register{..})  = (registerName, getRegType r, fromJust registerAddress)
    let regDefs = fmap mkRegDef rtlMappings

    let mkRegDecl (n,t,a) = printf "%s(%s,0x%08x)" n t a
    let regDecls     = javaEnumLines (fmap mkRegDecl regDefs) ++ "\n"
    let regHead      = "public enum Register {\n"
    let regConstBody = "this.address = address;\nthis.type = type;"
    let regConstr    = javaMethodDecl "" "" "Register" [typeEnum ++ " " ++ "type", "int address"] regConstBody
    let typeMap      = printf "private static Map<%s,List<Register>> typeMap = new HashMap<>();\n" typeEnum
    let addrMap      = "private static Map<Integer,List<Register>> addrMap = new HashMap<>();\n" 
    let mapDefs      = javaStaticBlock $ indent 1 ("for (Register r : EnumSet.allOf(Register.class)){\n"
                                     ++ "  List<Register> tList = typeMap.get(r.type);\n"
                                     ++ "  List<Register> aList = addrMap.get(r.address);\n"
                                     ++ "  if (tList == null){ tList = new ArrayList<>(); typeMap.put(r.type, tList); }\n"
                                     ++ "  tList.add(r);\n"
                                     ++ "  if (aList == null){ aList = new ArrayList<>(); addrMap.put(r.address, aList); }\n"
                                     ++ "  aList.add(r);\n"
                                     ++ "}\n")
    let fieldDefs    = printf "public final int address;\npublic final %s type;\n\n" typeEnum :: String
    let typeLookup   = javaMethodDecl javaPublic "static List<Register>" "getRegistersOfType" [typeEnum ++ " " ++ "type"] "return typeMap.get(type);"
    let addrLookup   = javaMethodDecl javaPublic "static List<Register>" "getRegistersAtAddress" ["int addr"] "return addrMap.get(addr);"
    let addrsLookupBody = "if (typeMap.get(type) == null) return new ArrayList<>();\nList<Integer> addrs = new ArrayList<>();\nfor (Register r : typeMap.get(type)){\n  addrs.add(r.address);\n}\nreturn addrs;\n"
    let addrsLookup  = javaMethodDecl javaPublic "static List<Integer>"  "getAddressesForType"  [typeEnum ++ " " ++ "type"] addrsLookupBody
    let klass = imports ++ regHead ++ indent 1 (regDecls ++ fieldDefs ++ regConstr ++ typeMap ++ addrMap ++ mapDefs ++ typeLookup ++ addrLookup ++ addrsLookup) ++ "\n}"
    javaFile "Register" klass

----------------------
-- Register Type Enum
----------------------
--
{-
javaRegTypeEnum :: [RegisterType] -> CodeGenerator String
javaRegTypeEnum types = do
    let names = fmap registerTypeName types
    addGenName jTypesEnumKey ("RegisterType" :: String)
    return $ javaEnum "RegisterType" names
    -}

-- NOTE: This generator needs to be run before javaRegisterEnum
javaRegisterTypeEnum :: [RegisterType] -> CodeGenerator GeneratedFile
javaRegisterTypeEnum types = do
    addGenName jTypesEnumKey ("RegisterType" :: String)
    let mkBuilder n    = "new RegisterBuilders." ++ (toCamelCase n ++ "RegisterType") ++ "()"
    let mkRegDef (n,b) = n ++ "(" ++ b ++ ")"
    let names          = fmap (\(RegisterType{..}) -> mkRegDef (registerTypeName, mkBuilder registerTypeName)) types
    let regDecls       = (javaEnumLines names) ++ "\n"
    let regConstr      = javaMethodDecl "" "" "RegisterType" ["RTLRegisterType builder"] "this.builder = builder;\n"
    let builderField   = "public final RTLRegisterType builder;\n\n"

    let imports        = concat [javaImport "com.samsung.ttt.rtlgen.*","\n"] 
    let enumHead       = "public enum RegisterType {\n"
    let enumBody       = indent 1 $ regDecls ++ builderField ++ regConstr 
    let enum           = imports ++ enumHead ++ enumBody ++ "\n" ++ "}"
    javaFile "RegisterType" enum
    
    



    



-------------
-- Constants
-------------
-- This generates a constants file

javaConstants :: [RTLConstant] -> CodeGenerator GeneratedFile
javaConstants l = do 
    let className = "Constants"
    let mkConst (RTLConstant{..}) = javaConst constName (show constValue) 
    let consts = javaLines  mkConst l
    let klass = javaClassDecl className consts True False Nothing
    javaFile className klass

---------------------------
-- Complete Register Object
---------------------------
-- This generates a java object with all the registers as fields.
-- This is for easy serialization of RTL state.

javaRegisterObject :: [Register] -> CodeGenerator GeneratedFile
javaRegisterObject regs = do
  let name      = "RTLComplete" :: String
  let regClass  = "RegisterBuilders" :: String
  let mkRegType (Register{..}) = regClass ++ "." ++ javaRegisterTypeNameToClass (registerTypeName registerType)
  let mkRegField r@(Register{..}) = do
        javaFieldDecl (mkRegType r) registerName Nothing True False

  let fields = javaLines mkRegField regs
  let constr = javaMethodDecl "public" name "" [] ""
  let klass  = javaClassDecl name (fields ++ constr) True False Nothing
  let about  = concat ["/** This class has been generated to allow for convenient serialization of the complete RTL state.\n"
                      ," *  It is optional and can be deleted.\n"
                      ," */\n\n"]

  javaFile name (about ++ klass)


-- TODO: This should be the function that gets exported. But since this module needs to temporarily
-- be compatible with CGen and JavaGen we'll export the old style interface instead
generateJavaCode' :: RTL -> CodeGenerator CodeGenResult
generateJavaCode' r@(RTL{..}) = do
    builders  <- javaRTLRegisterTypeClass r
    --accessors <- javaRegisterAccessors r
    consts    <- javaConstants rtlConstants
    complete  <- javaRegisterObject rtlMappings
    typeEnum  <- javaRegisterTypeEnum rtlRegisterTypes
    regEnum   <- javaRegisterEnum r
    return $ CodeGenResult [builders,  consts, complete, typeEnum, regEnum] []
    
generateJavaCode :: CodeGenConfig -> RTL -> CodeGenResult
generateJavaCode c@(CodeGenConfig{..}) r@(RTL{..}) = do
    let st = CodeGenState M.empty rtlPackageName cgDate cgCompilerVersion
    evalState (generateJavaCode' r) st
    

testFn fn out = do
    p <- parseRTLFile "rtl-test/rs70_complete.yaml"
    case p of
        Left err -> putStrLn err
        Right rtl -> do
            t <- getCurrentTime
            let st = CodeGenState M.empty (rtlPackageName rtl) t "1"
            let res = evalState (fn rtl) st
            out res

test = do
    let fn r@(RTL{..}) = javaRTLRegisterTypeClass r --ajavaRegisterAccessors rtlMappings
    testFn fn (putStrLn . fileSource)
    




    
