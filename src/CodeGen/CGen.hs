{-# LANGUAGE OverloadedStrings #-}
{-# LANGUAGE RecordWildCards #-}

module CodeGen.CGen (
  generateCCode
) where

import AST.Register
import CodeGen.CodeGenUtils
import CodeGen.Types
import Control.Monad
import Control.Applicative
import Control.Monad.State
import qualified Data.Foldable as F
import qualified Data.Traversable as F
import qualified Data.List as L
import qualified Data.Map as M

import Data.Time
import Data.Maybe
import Data.Monoid

import Data.Char

import Text.Printf

import System.FilePath

import AST.Parser

-- TODO: This should be shared between all code gens
data CGenState = CGenState {
      cCompilerVersion :: !String
    , cDate            :: !UTCTime
    , cPackageName     :: !String
    , cGenNames        :: M.Map String String
    } deriving Show

type GenState r = State CGenState r

type CFnArg = (String,String)

allCaps :: String -> String
allCaps s = fmap toUpper s

indent :: Int -> String -> String
indent n txt = do
    let t = replicate (n*4) ' '
    let l = lines txt
    F.foldl' (\s v -> s ++ (t ++ v ++ "\n" )) "" l

cStmt :: String -> String
cStmt v = v <> ";\n"

cStmts :: (a -> String) -> [a] -> String
cStmts fn xs = F.foldl' (\s x -> s ++ (cStmt $ fn x)) "" xs

cLines :: (a -> String) -> [a] -> String
cLines fn xs = F.foldl' (\s x -> s ++ (fn x)) "" xs

cInclude :: String -> String
cInclude v = printf "#include \"%s\"\n" v

cReturn :: String -> String
cReturn v = cStmt $ "return " ++ v

cVarDecl :: String -> String -> Maybe String -> String
cVarDecl typ name (Just v) = cStmt $ printf "%s %s = %s" typ name v
cVarDecl typ name Nothing  = cStmt $ printf "%s %s" typ name

cArgList :: [String] -> String
cArgList args = "(" <> L.intercalate ", " args <> ")"

cStructList :: [String] -> String
cStructList args = "{" <> L.intercalate ", " args <> "}"

cArrDecl :: String -> String -> Int -> [String] -> String
cArrDecl typ name size x = do
    let arrName = printf "%s [%d]" name size :: String
    let val = if null x then Nothing else Just $ cStructList x
    cVarDecl typ arrName val


cMacroDecl :: String -> [String] -> String -> String
cMacroDecl name args body = do
    let body' = L.intercalate "\\\n" $ L.lines body
    let args' = cArgList args
    printf "#define %s%s %s\n\n" name args' body'

cConstDecl :: String -> String -> String
cConstDecl name val = printf "#define %s %s\n" name val

cFunctionDecl' :: String -> String -> [String] -> String
cFunctionDecl' typ name args = do
    let args' = cArgList args
    L.intercalate " " [typ, name, args']

cFunctionDecl :: String -> String -> [String] -> String -> String
cFunctionDecl typ name args body = cFunctionDecl' typ name args ++ "{\n" ++ body ++ "}\n\n"

cFunctionDef :: String -> String -> [String] -> String -> String
cFunctionDef typ name args body = do
    let sig = cFunctionDecl' typ name args
    sig ++ "{\n" ++ indent 1 body ++ "\n}\n\n"

cStructDef :: String -> [String] -> String
cStructDef name fields = concat [ 
    printf "typedef struct %s {\n" name,
    indent 1 $ cStmts id fields, "}\n\n"]

cMethodCall :: Bool -> String -> String -> [String] -> String
cMethodCall ptr obj fn args = do
    let con = if ptr then "->" else "."
    obj ++ con ++ fn ++ cArgList args

cFieldAssign :: Bool -> String -> String -> String -> String
cFieldAssign ptr obj field val = do
    let con = if ptr then "->" else "."
    obj ++ con ++ field ++ " = " ++ val ++ ";\n"

cVarAssign :: String -> String -> String
cVarAssign var val = cStmt $ var ++ " = " ++ val

cFunctionCall :: String -> [String] -> String
cFunctionCall fn args = do
    fn ++ cArgList args

cTypeForFieldSize :: Integral a => a -> String
cTypeForFieldSize n 
    | n <= 8  = "uint8_t"
    | n <= 16 = "uint16_t"
    | n <= 32 = "uint32_t"

cPragmaOnce :: String 
cPragmaOnce = "#pragma once\n\n"

cDefsCombine :: Monad m => (a -> m String) -> [a] -> m String
cDefsCombine fn a = F.foldlM (\s x -> fmap (s++) (fn x)) "" a

cFileWarningComment :: GenState String
cFileWarningComment = do
    ver <- gets cCompilerVersion
    t   <- gets cDate
    let fmt = concat ["/** Generated by RTL-Gen Compiler version %s on %s\n",
                      " * DO NOT EDIT UNLESS YOU KNOW WHAT YOU ARE DOING\n",
                      " */\n\n"] :: String
    return $ printf fmt ver (show t)

addCName :: String -> String -> GenState ()
addCName k v = modify $ \s@(CGenState{..}) -> do
    let nm = M.insert k v cGenNames
    s{ cGenNames = nm }

getCName :: String -> GenState String
getCName k = do
    v <- M.lookup k <$> gets cGenNames
    return $ fromJust v
    
    

---------------------
-- RTL Register Types
---------------------

cHelperFuncs :: String
cHelperFuncs = concat [
        "#define RTL_bitmask(hi,lo) ((2 << (hi-lo))-1)\n",
        "#define RTL_mask_and_shift(v,hi,lo) ((v & RTL_bitmask(hi,lo)) << lo)\n",
        "#define RTL_extract_bytes(v,hi,lo) ((v >> lo) & RTL_bitmask(hi,lo))\n",
        "#define RTL_reg_size(v) (sizeof(v)/sizeof(uint32_t))\n"
    ]

cSetGetRegArgName :: String
cSetGetRegArgName = "reg"

cSetGetRegArg :: String
cSetGetRegArg = "uint32_t * " ++ cSetGetRegArgName

cSetterArgName :: String
cSetterArgName = "val"

cRegisterFieldSetterDecl :: Bool -> String -> RegisterField -> GenState String
cRegisterFieldSetterDecl proto regName (RegisterField{..}) = do
    ns <- gets cPackageName
    let cType = cTypeForFieldSize fieldBitSize
    let fnName = toSnake $ ns ++ "_" ++ "set" ++ "_" ++ regName ++ "_" ++ fieldName 
    let cSetterArg = cType ++ " " ++ cSetterArgName
    if proto
      then return $ cStmt $ cFunctionDecl' "void" fnName [cSetGetRegArg, cSetterArg] 
      else do
        let dest = printf "*(%s+%d)" cSetGetRegArgName (fieldWordOffset) :: String
        let body = printf "%s = (%s) | RTL_mask_and_shift(%s, %d, %d);\n" dest dest cSetterArgName fieldBitHigh fieldBitLow :: String
        return $ cFunctionDecl "void" fnName [cSetGetRegArg, cSetterArg] (indent 1 body)

cRegisterFieldGetterDecl :: Bool -> String -> RegisterField -> GenState String
cRegisterFieldGetterDecl proto regName (RegisterField{..}) = do
    ns <- gets cPackageName
    let fnName  = toSnake $ ns ++ "_" ++ "get" ++ "_" ++ regName ++ "_" ++ fieldName 
    let retType = cTypeForFieldSize fieldBitSize
    --let retType = "uint32_t"
    if proto
      then return $ cStmt $ cFunctionDecl' retType fnName [cSetGetRegArg] 
      else do
        let dest = printf "(*(%s+%d))" cSetGetRegArgName (fieldWordOffset) :: String
        let body = printf "return RTL_extract_bytes(%s, %d, %d);\n" dest fieldBitHigh fieldBitLow :: String
        return $ cFunctionDecl retType fnName [cSetGetRegArg] (indent 1 body)

cRegisterInstMacroDecl :: RegisterType -> GenState String
cRegisterInstMacroDecl (RegisterType{..}) = do
    ns <- gets cPackageName
    let macroName = allCaps ns ++ "_NEW_" ++ allCaps registerTypeName ++ "_REG"
    let body = printf "uint32_t %s [%d] = {0};\n" ("n"::String) registerTypeWordCount
    --let body = printf "uint8_t %s [%d] = {0};\n" ("n"::String) registerTypeByteSize
    return $ "\n\n" ++ cMacroDecl macroName ["n"] body

cRegisterAccessors :: RegisterType -> GenState String
cRegisterAccessors r@(RegisterType{..}) = do
    let getters = fmap (cRegisterFieldGetterDecl False registerTypeName) registerTypeFields
    let setters = fmap (cRegisterFieldSetterDecl False registerTypeName) registerTypeFields
    fmap concat $ F.sequence (setters ++ getters)

cRegisterAccessorsProtos :: RegisterType -> GenState String
cRegisterAccessorsProtos r@(RegisterType{..}) = do
    let getters = fmap (cRegisterFieldGetterDecl True registerTypeName) registerTypeFields
    let setters = fmap (cRegisterFieldSetterDecl True registerTypeName) registerTypeFields
    fmap concat $ F.sequence ((cRegisterInstMacroDecl r) : (setters ++ getters))

cGenerateAccessorFileHeader :: RTL -> GenState GeneratedFile
cGenerateAccessorFileHeader (RTL{..}) = do
    ns <- gets cPackageName 
    warning <- cFileWarningComment
    let fileName = ns </> (ns ++ "_register_builders.h")
    let includes = concat [cInclude "stdint.h",cInclude "stddef.h","\n"]
    sourceBody <- concat <$> F.mapM cRegisterAccessorsProtos rtlRegisterTypes
    let source = cPragmaOnce ++ warning ++ includes ++ cHelperFuncs ++ sourceBody
    return $ GeneratedFile source fileName
    
cGenerateAccessorFile :: RTL -> GenState GeneratedFile
cGenerateAccessorFile (RTL{..}) = do
    ns <- gets cPackageName 
    warning <- cFileWarningComment
    let fileBase = (ns ++ "_register_builders")
    let header   = fileBase ++ ".h"
    let cFile    = fileBase ++ ".c"
    let fileName = ns </> cFile
    let includes = cInclude header ++ "\n"
    sourceBody <- concat <$> F.mapM cRegisterAccessors rtlRegisterTypes
    let source = warning ++ includes ++ sourceBody
    return $ GeneratedFile source fileName

---------------------
-- Register Interface
---------------------

cRegistersEnumKey :: String
cRegistersEnumKey = "bankEnum"

cRegistersAddrsKey :: String
cRegistersAddrsKey = "reg_offsets_array"

cRegisterSizesKey  :: String
cRegisterSizesKey = "regSizes"

cRegistersAccessFnProtoKey :: String
cRegistersAccessFnProtoKey = "reg_access_fn"

cRegisterSizeFnProtoKey :: String
cRegisterSizeFnProtoKey = "registerSizeFn"

cRegistersEnum :: [Register] -> GenState String
cRegistersEnum regs = do
    ns <- gets cPackageName
    let def (x,n) = x ++ " = " ++ (show n) ++ ",\n" :: String
    let tName = toSnake $ ns ++ "_type"
    addCName cRegistersEnumKey tName
    let enumNames = fmap (toSnake . (\s ->ns ++ "_" ++ s) . registerName) regs
    let body  = indent 1 $ cLines def (zip enumNames [0..])
    return $ printf "typedef enum %s {\n%s} %s;\n" tName body tName;

cRegisterAddressesArray :: [Register] -> GenState String
cRegisterAddressesArray regs = do
    ns <- gets cPackageName
    let addrs = fmap (fromJust . registerAddress) regs
    let arrName  = "_" ++ ns ++ "_" ++ "register_addresses"
    addCName cRegistersAddrsKey arrName
    return $ "static " ++ cArrDecl "uint32_t" arrName (length addrs) (fmap showHex addrs)

-- TODO: This a hack to work around registers that have less than 32bits of data
cRegisterSizeArray :: [Register] -> GenState String
cRegisterSizeArray regs = do
    ns <- gets cPackageName
    let sizes = fmap (registerTypeByteSize . registerType) regs
    let arrName = "_" ++ ns ++ "_" ++ "register_sizes"
    addCName cRegisterSizesKey arrName
    return $ "static " ++ cArrDecl "size_t" arrName (length sizes) (fmap show sizes)

cConstant :: RTLConstant -> String
cConstant (RTLConstant{..}) = cConstDecl constName (show constValue)

cRegisterIFaceHeader :: RTL -> GenState GeneratedFile
cRegisterIFaceHeader (RTL{..}) = do
    warn  <- cFileWarningComment
    enum  <- cRegistersEnum rtlMappings
    enumT <- getCName cRegistersEnumKey
    ns    <- gets cPackageName
    let fnName = ns ++ "_get_register"
    let sizeFnName = ns ++ "_register_size"
    let fn = cFunctionDecl' "uint32_t*" fnName [enumT ++ " reg"]
    let sizeFn = cFunctionDecl' "size_t" sizeFnName [enumT ++ " reg"]
    addCName cRegistersAccessFnProtoKey fn
    addCName cRegisterSizeFnProtoKey sizeFn
    let includes = cInclude "stdint.h" ++ cInclude "stddef.h" ++ "\n"
    let consts = cLines cConstant rtlConstants ++ "\n"
    let src = cPragmaOnce ++ warn ++ includes ++ consts ++ enum ++ "\n" ++ cStmt fn ++ cStmt sizeFn
    let fileName = ns </> ns ++ "_register_accessors.h"
    return $ GeneratedFile src fileName

cRegisterIFaceSource :: RTL -> GenState GeneratedFile
cRegisterIFaceSource (RTL{..}) = do
    addrs       <- cRegisterAddressesArray rtlMappings
    sizes       <- cRegisterSizeArray rtlMappings
    addrArrName <- getCName cRegistersAddrsKey
    sizeArrName <- getCName cRegisterSizesKey
    proto1      <- getCName cRegistersAccessFnProtoKey
    proto2      <- getCName cRegisterSizeFnProtoKey
    ns          <- gets cPackageName
    warn        <- cFileWarningComment
    let addrFnBody = printf "return (uint32_t*) %s[reg];\n" addrArrName
    let addrFn = "\n" ++ proto1 ++ "{\n    " ++ addrFnBody ++ "}\n\n"
    let sizeFnBody = printf "return %s[reg];\n" sizeArrName
    let sizeFn = "\n" ++ proto2 ++ "{\n    " ++ sizeFnBody ++ "}\n\n"
    let fileN = ns ++ "_register_accessors"
    let includes = cInclude (fileN ++ ".h") ++ "\n"
    let src = cPragmaOnce ++ warn ++ includes ++ addrs ++ sizes ++ addrFn ++ sizeFn
    return $ GeneratedFile src (ns </> fileN ++ ".c")

cRegisterIFace :: RTL -> GenState [GeneratedFile]
cRegisterIFace r = do
    h <- cRegisterIFaceHeader r
    c <- cRegisterIFaceSource r
    return $ [h,c]


generateAllC :: RTL -> GenState CodeGenResult
generateAllC r@(RTL{..}) = do
    accessorsH <- cGenerateAccessorFileHeader r
    accessors  <- cGenerateAccessorFile r
    iface <- cRegisterIFace r
    return $ CodeGenResult ([accessorsH, accessors] ++ iface) []
    
generateCCode :: CodeGenConfig -> RTL -> CodeGenResult
generateCCode c@(CodeGenConfig{..}) r@(RTL{..}) = do
    let st = CGenState cgCompilerVersion cgDate rtlPackageName M.empty
    evalState (generateAllC r) st
    










