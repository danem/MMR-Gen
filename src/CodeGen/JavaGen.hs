{-# LANGUAGE NoMonomorphismRestriction #-}
{-# LANGUAGE RecordWildCards #-}
{-# LANGUAGE NoOverloadedStrings #-}

-- TODO: VERY MESSY. REFACTOR USING READER MONAD.

module CodeGen.JavaGen (
    generateJavaCode
) where 

import AST.Register
import CodeGen.Types
import CodeGen.CodeGenUtils
import qualified Data.Foldable as F
import qualified Data.Traversable as F
import qualified Data.List as L
import Data.Word
import Data.Char
import Text.Printf
import Data.Maybe
import System.FilePath

javaRegisterFieldType :: RegisterField -> String
javaRegisterFieldType (RegisterField{..}) = if fieldBitSize == 1 then "boolean" else "int"

javaWarningComment :: CodeGenConfig -> String
javaWarningComment (CodeGenConfig{..}) = concat [
        printf "/** Generated by RTL-Gen compiler version: %s on %s.\n" cgCompilerVersion (show cgDate),
        " *\n",
        " * DO NOT EDIT UNLESS YOU KNOW WHAT YOU ARE DOING\n",
        " * @generated\n",
        " */\n\n"
    ]

indent :: Int -> String -> String
indent n txt = do
    let t = replicate (n*4) ' '
    let l = lines txt
    F.foldl' (\s v -> s ++ (t ++ v ++ "\n")) "" l

javaStmt :: String -> String
javaStmt expr = expr ++ ";\n"

javaInteger :: String
javaInteger = "Integer"

javaPrivate :: String
javaPrivate = "private"

javaPublic :: String
javaPublic = "public"

javaImport :: String -> String
javaImport pkg = "import " ++ javaStmt pkg

javaReturn :: String -> String
javaReturn v = "return " ++ javaStmt v 

javaMethodCall :: String -> String -> [String] -> String
javaMethodCall obj m args = obj ++ "." ++ m ++ "(" ++ L.intercalate ", " args ++ ")"

javaMethodDecl :: String -> String -> String -> [String] -> String -> String
javaMethodDecl access ret name args body = access ++ " " 
                                        ++ ret ++ " " 
                                        ++ name ++ " (" ++ L.intercalate ", " args ++ "){\n"
                                        ++ indent 1 body ++ "}\n\n"

javaClassDecl :: String -> String -> Bool -> Bool -> Maybe String -> String
javaClassDecl name body access static extends = do
    let access' = (if access then "public" else "private") :: String
    let static' = (if static then " static" else "") :: String
    let extends' = fromMaybe "" (fmap (\s -> " extends " ++ s) extends)
    printf "%s%s class %s%s {\n%s\n}\n\n" access' static' name extends' (indent 1 body)

javaEnum :: String -> [String] -> String
javaEnum name idents = do 
    let o = "public enum " ++ name ++ " {\n"
    let b = F.foldl' (\s n -> s ++ "  "++ n ++ ",\n") "" idents
    o ++ b ++ "}\n"

javaVarDecl :: String -> String -> String -> String
javaVarDecl typ name val = javaStmt $ printf "%s %s = %s" typ name val

javaAssignment :: String -> String -> String -> String
javaAssignment obj field val = printf "%s.%s = %s;\n" obj field val

javaCastIntToBoolean :: String -> String -> String
javaCastIntToBoolean var temp = javaVarDecl "boolean" temp (printf "%s == 1" var)

javaCastBooleanToInt :: String -> String -> String
javaCastBooleanToInt var temp = javaVarDecl "int" temp (printf "%s ? 1 : 0" var)

javaFieldDecl :: String -> String -> Maybe String -> Bool -> Bool -> String
javaFieldDecl typ name val public static = do
    let public' = if public then "public" else "private"
    let static' = if static then "static " else ""
    let val' = fromMaybe "" (fmap (" = " ++) val)
    printf "%s %s%s %s%s;\n" public' static' typ name val'

toJavaFile :: String -> String
toJavaFile s = s ++ ".java"

toJavaPackage :: String -> String
toJavaPackage = id -- TODO

javaPackage :: String -> String
javaPackage name = (javaStmt $ "package " ++ name) ++ "\n"
----------------------
-- RTLRegisterType Gen
----------------------
javaRTLSetParam :: String
javaRTLSetParam = "data"

javaRTLExtractParam :: String
javaRTLExtractParam = "x"

javaRTLTempParam :: String
javaRTLTempParam = "temp"

javaExtractBytes :: Word32 -> Word32 -> Word32 -> String
javaExtractBytes word hi lo = javaMethodCall "this" "extractBytes" [show word, show hi, show lo]

javaShiftAndMaskBytes :: String -> Word32 -> Word32 -> Word32 -> String
javaShiftAndMaskBytes val word hi lo = javaMethodCall "this" "maskAndShift" [val, show word, show hi, show lo]

javaRegisterFieldGet :: RegisterField -> String
javaRegisterFieldGet (RegisterField{..}) = do
    let ext = javaVarDecl "int" javaRTLExtractParam $ javaExtractBytes fieldWordOffset fieldBitHigh fieldBitLow
    ext ++ if fieldBitSize /= 1
      then javaReturn "x"
      else javaCastIntToBoolean "x" "temp" ++ javaReturn "temp"

javaRegisterFieldGetter :: RegisterField -> String
javaRegisterFieldGetter r@(RegisterField{..}) = do
    let name = "get_" ++ fieldName
    let typ  = javaRegisterFieldType r
    javaMethodDecl javaPublic typ name [] (javaRegisterFieldGet r)

javaRegisterFieldSet :: RegisterField -> String
javaRegisterFieldSet (RegisterField{..}) = do
    let (castStmt,var) = if fieldBitSize /= 1
        then ("", javaRTLSetParam)
        else (javaCastBooleanToInt javaRTLSetParam javaRTLTempParam, javaRTLTempParam)
    let set = javaStmt $ javaShiftAndMaskBytes var fieldWordOffset fieldBitHigh fieldBitLow
    castStmt ++ set ++ javaReturn "this"

javaRegisterFieldSetter :: String -> RegisterField -> String
javaRegisterFieldSetter className r@(RegisterField{..}) = do
    let name = "set_" ++ fieldName
    let typ  = javaRegisterFieldType r
    javaMethodDecl javaPublic className name [typ ++ " " ++ javaRTLSetParam] (javaRegisterFieldSet r)


javaRTLRegisterTypeGetSet :: String -> RegisterField -> String
javaRTLRegisterTypeGetSet className r@(RegisterField{..}) = do
    javaRegisterFieldGetter r ++ javaRegisterFieldSetter className r

javaRTLRegisterTypeConstructors :: String -> RegisterType -> String
javaRTLRegisterTypeConstructors name (RegisterType{..}) = do
    let types  = fmap javaRegisterFieldType registerTypeFields
    let fnames = fmap fieldName $ registerTypeFields
    let cArgs  = zipWith (\a b-> a ++ " " ++ b) types fnames
    let bodyS  = "super(" ++ show registerTypeWordCount ++ ");\n"
    let body   = bodyS ++ (concat $ fmap (\n -> javaStmt $ javaMethodCall "this" ("set_"++n) [n]) fnames)
    let c1     = javaMethodDecl javaPublic name "" cArgs body
    let c2     = javaMethodDecl javaPublic name "" [] bodyS
    c2 ++ c1
    

javaRTLRegisterTypeClassBody :: String -> RegisterType -> String
javaRTLRegisterTypeClassBody name (RegisterType{..}) = do
    let getsets = F.foldl' (\s f -> s ++ (javaRTLRegisterTypeGetSet name f)) "" registerTypeFields
    getsets

javaRTLRegisterTypeDecl :: RegisterType -> String
javaRTLRegisterTypeDecl r@(RegisterType {..}) = do
    let name = toCamelCase registerTypeName ++ "RegisterType"
    let body = indent 1 $ (javaRTLRegisterTypeConstructors name r) ++ "\n"
                       ++ (javaRTLRegisterTypeClassBody name r)
    javaClassDecl name body True True (Just "RTLRegisterType")

javaRTLRegisterTypeClass :: String -> String -> CodeGenConfig -> RTL -> GeneratedFile
javaRTLRegisterTypeClass pkg name c r@(RTL{..}) = do
    let jpkg = javaPackage pkg
    let imports = concat [javaImport "com.samsung.ttt.rtlgen.RTLRegisterType", "\n"]
    let body = indent 1 $ F.foldl' (\s c -> s ++ javaRTLRegisterTypeDecl c) "" rtlRegisterTypes
    let klass = javaClassDecl name body True False Nothing
    GeneratedFile (jpkg ++ javaWarningComment c ++ imports ++ klass) (toJavaFile (pkg </> name))

---------------------
-- Register Interface
---------------------
javaRegConfiguratorCreate :: String -> String -> Word32 -> String
javaRegConfiguratorCreate typ name wsize = do
    let decl   = (printf "RegisterConfigurator<%s> %s = new RegisterConfigurator<%s>() {\n" typ name typ) :: String
    let fnComment = "// User implementation here.\n// TODO: Compiler should return an array the size of the register. ie: new DmuxRegisterType().getValues();\n"
    let fnBody    = fnComment ++ "return new int[" ++ show wsize ++ "];\n"
    let fn     = indent 1 $ javaMethodDecl javaPublic "int[]" "configure" [typ ++ " " ++ "config", "int n"] fnBody
    decl ++ fn ++ "};\n\n"

javaRegInterfaceGetConfigurators :: String -> [String] -> String
javaRegInterfaceGetConfigurators conf names = do
    let decl = printf "protected List<RegisterConfigurator<%s>> getConfigurators (){\n" conf
    let comment = "// Generated by compiler. DO NOT TOUCH\n"
    let arr  = printf "ArrayList<RegisterConfigurator<%s>> configurators = new ArrayList<>();\n" conf
    let s = F.foldl' (\s x -> s ++ (javaStmt $ javaMethodCall "configurators" "add" [x])) "" names
    let body = indent 1 (comment ++ arr ++ s ++ javaReturn "configurators")
    decl ++ body ++ "}\n\n"

javaRegInterfaceGenerateAddress :: String
javaRegInterfaceGenerateAddress = concat [
        "@Override\n",
        "protected int generateAddress(int baseAddress, int wordOffset){\n",
        "    // User implementation here.\n",
        "    return baseAddress + wordOffset;\n",
        "}\n"
    ]

rtlTypeToJavaType :: RTLInterfaceType -> String
rtlTypeToJavaType RTLNum  = "Double"
rtlTypeToJavaType RTLBool = "Boolean"
rtlTypeToJavaType (RTLArray x) = "List<" ++ rtlTypeToJavaType x ++ ">"

javaRegInterfaceClassDecl :: String -> String -> String -> RegisterBank -> String
javaRegInterfaceClassDecl pkg className confType (RegisterBank{..}) = do
    let jpkg = javaStmt $ "package " ++ pkg
    let imports = concat [javaImport "com.samsung.ttt.rtlgen.RegisterInterface"
                         ,javaImport "com.samsung.ttt.rtlgen.RegisterConfigurator"
                         ,javaImport (pkg ++ "." ++ confType)
                         ,javaImport "java.util.ArrayList"
                         ,javaImport "java.util.List"
                         ,"\n"]

    let regNames      = fmap (toCamelCase . registerTypeName . registerType) bankRegisters
    -- TODO: Hack
    let regSizes      = fmap (registerTypeWordCount . registerType) bankRegisters
    let regs          = zip regNames regSizes
    let confs         = fmap (\(s,w) -> (s ++ "Config",w)) regs
    let confNames     = fmap fst confs
    let confInsts     = L.nub confs
    let configurators = F.foldl' (\s (x,w) -> s ++ javaRegConfiguratorCreate confType x w) "" confInsts
    let constr        = javaMethodDecl javaPublic className "" [] (javaStmt $ "super(" ++ show bankBaseAddress ++ ")")
    let getConfigs    = javaRegInterfaceGetConfigurators confType confNames
    let body = constr ++ getConfigs ++ configurators ++ javaRegInterfaceGenerateAddress
    jpkg ++ imports ++ javaClassDecl className body True False (Just $ printf "RegisterInterface<%s>" confType)

javaRegInterfaceConfigClass :: String -> String -> [RegisterBankInterfaceType] -> String
javaRegInterfaceConfigClass  pkg conftyp pa = do
    let jpkg = javaStmt $ "package " ++ pkg
    let imports = concat [javaImport "java.util.List","\n"]
    let fieldDecl f (RegisterBankInterfaceType{..}) = f ++ javaFieldDecl (rtlTypeToJavaType paramType) paramName Nothing True False
    let fields = F.foldl' fieldDecl "" pa
    let cargs  = fmap (\(RegisterBankInterfaceType{..}) -> rtlTypeToJavaType paramType ++ " " ++ paramName) pa
    let cbody  = F.foldl (\s (RegisterBankInterfaceType{..}) -> s ++ javaAssignment "this" paramName paramName) "" pa
    let constr = javaMethodDecl javaPublic conftyp "" cargs cbody
    let body   = fields ++ constr
    jpkg ++ imports ++ javaClassDecl conftyp body True False Nothing


javaRegInterfaceClass :: String -> CodeGenConfig -> RegisterBank -> [GeneratedFile]
javaRegInterfaceClass pkgDir cg r@(RegisterBank{..}) = do
    let name = toCamelCase bankName
    let confName  = name ++ "InterfaceConfig"
    let ifaceName = name ++ "Interface"
    let jpkg      = toJavaPackage pkgDir
    let comment   = javaWarningComment cg
    let iface     = comment ++ javaRegInterfaceClassDecl jpkg ifaceName confName r
    let conf      = comment ++ javaRegInterfaceConfigClass jpkg confName bankParameters
    [GeneratedFile iface $ toJavaFile (pkgDir </> ifaceName), GeneratedFile conf $ toJavaFile (pkgDir </> confName)]


generateJavaCode :: CodeGenConfig -> RTL -> CodeGenResult
generateJavaCode c@(CodeGenConfig{..}) r@(RTL{..}) = do
    let tcName = (toCamelCase rtlPackageName) ++ "RegisterTypes"
    let regs   = javaRTLRegisterTypeClass rtlPackageName tcName c r
    let ifaces = concat $ fmap (javaRegInterfaceClass rtlPackageName c) (rtlRegisterBanks)
    CodeGenResult [regs] ifaces
